{"ast":null,"code":"import { supabase } from '../supabaseClient';\nconst getFICCStatus = message => {\n  if (message.messageType === '509') {\n    var _message$status;\n    return ((_message$status = message.status) === null || _message$status === void 0 ? void 0 : _message$status.type) || 'PENDING';\n  }\n  return 'PENDING';\n};\nconst getFICCReference = message => {\n  var _message$genl;\n  return ((_message$genl = message.genl) === null || _message$genl === void 0 ? void 0 : _message$genl.seme) || null;\n};\nconst getCounterpartyRef = message => {\n  if (message.confDetails) {\n    var _message$confDetails$, _message$confDetails$2;\n    // For MT515/MT518 messages\n    const buyerParty = (_message$confDetails$ = message.confDetails.parties) === null || _message$confDetails$ === void 0 ? void 0 : _message$confDetails$.find(p => p.role === 'BUYR');\n    const sellerParty = (_message$confDetails$2 = message.confDetails.parties) === null || _message$confDetails$2 === void 0 ? void 0 : _message$confDetails$2.find(p => p.role === 'SELL');\n    return (buyerParty === null || buyerParty === void 0 ? void 0 : buyerParty.reference) || (sellerParty === null || sellerParty === void 0 ? void 0 : sellerParty.reference);\n  }\n  return null;\n};\nexport const matchTradeToFICCMessage = async message => {\n  var _message$genl2, _message$genl3, _message$genl3$refere, _message$genl3$refere2, _message$genl4, _message$status2;\n  // First store the message\n  const {\n    error: insertError\n  } = await supabase.from('ficc_messages').insert({\n    message_type: message.header.messageType.split('/')[0],\n    sender: message.header.sender,\n    receiver: message.header.receiver,\n    reference_id: (_message$genl2 = message.genl) === null || _message$genl2 === void 0 ? void 0 : _message$genl2.seme,\n    trade_reference: (_message$genl3 = message.genl) === null || _message$genl3 === void 0 ? void 0 : (_message$genl3$refere = _message$genl3.references) === null || _message$genl3$refere === void 0 ? void 0 : (_message$genl3$refere2 = _message$genl3$refere.find(r => r.qualifier === 'MAST')) === null || _message$genl3$refere2 === void 0 ? void 0 : _message$genl3$refere2.reference,\n    message_function: (_message$genl4 = message.genl) === null || _message$genl4 === void 0 ? void 0 : _message$genl4.messageFunction,\n    status_type: (_message$status2 = message.status) === null || _message$status2 === void 0 ? void 0 : _message$status2.type,\n    message_content: message,\n    created_at: new Date().toISOString(),\n    is_processed: false\n  });\n  if (insertError) {\n    console.error('Error storing FICC message:', insertError);\n    return null;\n  }\n\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    quantity,\n    cusip,\n    counterparty\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const {\n    data: potentialMatches,\n    error\n  } = await supabase.from('trades').select('*').eq('tradedate', tradeDate).eq('settlementdate', settlementDate).eq('cusip', cusip)\n  // Add tolerance for price/amount matching\n  .gte('price', price * 0.9999).lte('price', price * 1.0001);\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  if (bestMatch) {\n    var _message$genl5;\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n\n    // Update ficc_message with matched trade\n    await supabase.from('ficc_messages').update({\n      matched_trade_id: bestMatch.id,\n      is_processed: true\n    }).eq('reference_id', (_message$genl5 = message.genl) === null || _message$genl5 === void 0 ? void 0 : _message$genl5.seme);\n    return bestMatch;\n  }\n  return null;\n};\nconst extractTradeDetails = message => {\n  var _confDetails$parties, _confDetails$parties$;\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    quantity: confDetails.quantity || confDetails.amount / confDetails.price,\n    // Calculate quantity if not provided\n    cusip: confDetails.security,\n    counterparty: (_confDetails$parties = confDetails.parties) === null || _confDetails$parties === void 0 ? void 0 : (_confDetails$parties$ = _confDetails$parties.find(p => p.role === (message.header.sender === 'GSCCTRRS' ? 'BUYR' : 'SELL'))) === null || _confDetails$parties$ === void 0 ? void 0 : _confDetails$parties$.id\n  };\n};\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  if (!potentialMatches || potentialMatches.length === 0) return null;\n\n  // If only one match, return it\n  if (potentialMatches.length === 1) return potentialMatches[0];\n\n  // Score each potential match\n  const scoredMatches = potentialMatches.map(trade => {\n    let score = 0;\n    const messageDetails = extractTradeDetails(ficcMessage);\n\n    // Exact quantity match\n    if (trade.quantity === messageDetails.quantity) score += 5;\n\n    // Price match within tolerance\n    if (Math.abs(trade.price - messageDetails.price) < 0.0001) score += 3;\n\n    // Counterparty match\n    if (trade.counterparty === messageDetails.counterparty) score += 4;\n\n    // CUSIP match\n    if (trade.cusip === messageDetails.cusip) score += 5;\n\n    // Date matches\n    if (trade.tradedate.toISOString().split('T')[0] === messageDetails.tradeDate) score += 2;\n    if (trade.settlementdate.toISOString().split('T')[0] === messageDetails.settlementDate) score += 2;\n    return {\n      trade,\n      score\n    };\n  });\n\n  // Sort by score descending\n  scoredMatches.sort((a, b) => b.score - a.score);\n\n  // Return the trade with highest score if it meets minimum threshold\n  return scoredMatches[0].score >= 10 ? scoredMatches[0].trade : null;\n};\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const {\n    error\n  } = await supabase.from('trades').update({\n    ficc_status: getFICCStatus(ficcMessage),\n    ficc_reference: getFICCReference(ficcMessage),\n    counterparty_reference: getCounterpartyRef(ficcMessage),\n    comparison_status: getComparisonStatus(ficcMessage),\n    message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n  }).eq('id', tradeId);\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n};\nconst getComparisonStatus = message => {\n  if (message.messageType === '509') {\n    var _message$status3, _message$status3$type, _message$status4, _message$status4$type, _message$status5, _message$status5$type;\n    if ((_message$status3 = message.status) !== null && _message$status3 !== void 0 && (_message$status3$type = _message$status3.type) !== null && _message$status3$type !== void 0 && _message$status3$type.includes('MACH')) return 'Matched';\n    if ((_message$status4 = message.status) !== null && _message$status4 !== void 0 && (_message$status4$type = _message$status4.type) !== null && _message$status4$type !== void 0 && _message$status4$type.includes('REJT')) return 'Rejected';\n    if ((_message$status5 = message.status) !== null && _message$status5 !== void 0 && (_message$status5$type = _message$status5.type) !== null && _message$status5$type !== void 0 && _message$status5$type.includes('PACK')) return 'Accepted';\n  }\n  return 'Pending';\n};","map":{"version":3,"names":["supabase","getFICCStatus","message","messageType","_message$status","status","type","getFICCReference","_message$genl","genl","seme","getCounterpartyRef","confDetails","_message$confDetails$","_message$confDetails$2","buyerParty","parties","find","p","role","sellerParty","reference","matchTradeToFICCMessage","_message$genl2","_message$genl3","_message$genl3$refere","_message$genl3$refere2","_message$genl4","_message$status2","error","insertError","from","insert","message_type","header","split","sender","receiver","reference_id","trade_reference","references","r","qualifier","message_function","messageFunction","status_type","message_content","created_at","Date","toISOString","is_processed","console","tradeDate","settlementDate","price","quantity","cusip","counterparty","extractTradeDetails","data","potentialMatches","select","eq","gte","lte","bestMatch","findBestMatch","_message$genl5","updateTradeWithFICCInfo","id","update","matched_trade_id","_confDetails$parties","_confDetails$parties$","amount","security","ficcMessage","length","scoredMatches","map","trade","score","messageDetails","Math","abs","tradedate","settlementdate","sort","a","b","tradeId","ficc_status","ficc_reference","counterparty_reference","comparison_status","getComparisonStatus","message_history","raw","_message$status3","_message$status3$type","_message$status4","_message$status4$type","_message$status5","_message$status5$type","includes"],"sources":["/Users/joelaird/TradeRecon/src/services/matchingService.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\nconst getFICCStatus = (message) => {\n  if (message.messageType === '509') {\n    return message.status?.type || 'PENDING';\n  }\n  return 'PENDING';\n};\n\nconst getFICCReference = (message) => {\n  return message.genl?.seme || null;\n};\n\nconst getCounterpartyRef = (message) => {\n  if (message.confDetails) {\n    // For MT515/MT518 messages\n    const buyerParty = message.confDetails.parties?.find(p => p.role === 'BUYR');\n    const sellerParty = message.confDetails.parties?.find(p => p.role === 'SELL');\n    return buyerParty?.reference || sellerParty?.reference;\n  }\n  return null;\n};\n\nexport const matchTradeToFICCMessage = async (message) => {\n  // First store the message\n  const { error: insertError } = await supabase\n    .from('ficc_messages')\n    .insert({\n      message_type: message.header.messageType.split('/')[0],\n      sender: message.header.sender,\n      receiver: message.header.receiver,\n      reference_id: message.genl?.seme,\n      trade_reference: message.genl?.references?.find(r => r.qualifier === 'MAST')?.reference,\n      message_function: message.genl?.messageFunction,\n      status_type: message.status?.type,\n      message_content: message,\n      created_at: new Date().toISOString(),\n      is_processed: false\n    });\n\n  if (insertError) {\n    console.error('Error storing FICC message:', insertError);\n    return null;\n  }\n\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    quantity,\n    cusip,\n    counterparty\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const { data: potentialMatches, error } = await supabase\n    .from('trades')\n    .select('*')\n    .eq('tradedate', tradeDate)\n    .eq('settlementdate', settlementDate)\n    .eq('cusip', cusip)\n    // Add tolerance for price/amount matching\n    .gte('price', price * 0.9999)\n    .lte('price', price * 1.0001);\n\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  \n  if (bestMatch) {\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n    \n    // Update ficc_message with matched trade\n    await supabase\n      .from('ficc_messages')\n      .update({ \n        matched_trade_id: bestMatch.id,\n        is_processed: true\n      })\n      .eq('reference_id', message.genl?.seme);\n\n    return bestMatch;\n  }\n\n  return null;\n};\n\nconst extractTradeDetails = (message) => {\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    quantity: confDetails.quantity || (confDetails.amount / confDetails.price), // Calculate quantity if not provided\n    cusip: confDetails.security,\n    counterparty: confDetails.parties?.find(p => \n      p.role === (message.header.sender === 'GSCCTRRS' ? 'BUYR' : 'SELL')\n    )?.id\n  };\n};\n\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  if (!potentialMatches || potentialMatches.length === 0) return null;\n\n  // If only one match, return it\n  if (potentialMatches.length === 1) return potentialMatches[0];\n\n  // Score each potential match\n  const scoredMatches = potentialMatches.map(trade => {\n    let score = 0;\n    const messageDetails = extractTradeDetails(ficcMessage);\n\n    // Exact quantity match\n    if (trade.quantity === messageDetails.quantity) score += 5;\n\n    // Price match within tolerance\n    if (Math.abs(trade.price - messageDetails.price) < 0.0001) score += 3;\n\n    // Counterparty match\n    if (trade.counterparty === messageDetails.counterparty) score += 4;\n\n    // CUSIP match\n    if (trade.cusip === messageDetails.cusip) score += 5;\n\n    // Date matches\n    if (trade.tradedate.toISOString().split('T')[0] === messageDetails.tradeDate) score += 2;\n    if (trade.settlementdate.toISOString().split('T')[0] === messageDetails.settlementDate) score += 2;\n\n    return { trade, score };\n  });\n\n  // Sort by score descending\n  scoredMatches.sort((a, b) => b.score - a.score);\n\n  // Return the trade with highest score if it meets minimum threshold\n  return scoredMatches[0].score >= 10 ? scoredMatches[0].trade : null;\n};\n\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const { error } = await supabase\n    .from('trades')\n    .update({\n      ficc_status: getFICCStatus(ficcMessage),\n      ficc_reference: getFICCReference(ficcMessage),\n      counterparty_reference: getCounterpartyRef(ficcMessage),\n      comparison_status: getComparisonStatus(ficcMessage),\n      message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n    })\n    .eq('id', tradeId);\n\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n};\n\nconst getComparisonStatus = (message) => {\n  if (message.messageType === '509') {\n    if (message.status?.type?.includes('MACH')) return 'Matched';\n    if (message.status?.type?.includes('REJT')) return 'Rejected';\n    if (message.status?.type?.includes('PACK')) return 'Accepted';\n  }\n  return 'Pending';\n}; "],"mappings":"AAAA,SAASA,QAAQ,QAAQ,mBAAmB;AAE5C,MAAMC,aAAa,GAAIC,OAAO,IAAK;EACjC,IAAIA,OAAO,CAACC,WAAW,KAAK,KAAK,EAAE;IAAA,IAAAC,eAAA;IACjC,OAAO,EAAAA,eAAA,GAAAF,OAAO,CAACG,MAAM,cAAAD,eAAA,uBAAdA,eAAA,CAAgBE,IAAI,KAAI,SAAS;EAC1C;EACA,OAAO,SAAS;AAClB,CAAC;AAED,MAAMC,gBAAgB,GAAIL,OAAO,IAAK;EAAA,IAAAM,aAAA;EACpC,OAAO,EAAAA,aAAA,GAAAN,OAAO,CAACO,IAAI,cAAAD,aAAA,uBAAZA,aAAA,CAAcE,IAAI,KAAI,IAAI;AACnC,CAAC;AAED,MAAMC,kBAAkB,GAAIT,OAAO,IAAK;EACtC,IAAIA,OAAO,CAACU,WAAW,EAAE;IAAA,IAAAC,qBAAA,EAAAC,sBAAA;IACvB;IACA,MAAMC,UAAU,IAAAF,qBAAA,GAAGX,OAAO,CAACU,WAAW,CAACI,OAAO,cAAAH,qBAAA,uBAA3BA,qBAAA,CAA6BI,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAK,MAAM,CAAC;IAC5E,MAAMC,WAAW,IAAAN,sBAAA,GAAGZ,OAAO,CAACU,WAAW,CAACI,OAAO,cAAAF,sBAAA,uBAA3BA,sBAAA,CAA6BG,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAK,MAAM,CAAC;IAC7E,OAAO,CAAAJ,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,SAAS,MAAID,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEC,SAAS;EACxD;EACA,OAAO,IAAI;AACb,CAAC;AAED,OAAO,MAAMC,uBAAuB,GAAG,MAAOpB,OAAO,IAAK;EAAA,IAAAqB,cAAA,EAAAC,cAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,cAAA,EAAAC,gBAAA;EACxD;EACA,MAAM;IAAEC,KAAK,EAAEC;EAAY,CAAC,GAAG,MAAM9B,QAAQ,CAC1C+B,IAAI,CAAC,eAAe,CAAC,CACrBC,MAAM,CAAC;IACNC,YAAY,EAAE/B,OAAO,CAACgC,MAAM,CAAC/B,WAAW,CAACgC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACtDC,MAAM,EAAElC,OAAO,CAACgC,MAAM,CAACE,MAAM;IAC7BC,QAAQ,EAAEnC,OAAO,CAACgC,MAAM,CAACG,QAAQ;IACjCC,YAAY,GAAAf,cAAA,GAAErB,OAAO,CAACO,IAAI,cAAAc,cAAA,uBAAZA,cAAA,CAAcb,IAAI;IAChC6B,eAAe,GAAAf,cAAA,GAAEtB,OAAO,CAACO,IAAI,cAAAe,cAAA,wBAAAC,qBAAA,GAAZD,cAAA,CAAcgB,UAAU,cAAAf,qBAAA,wBAAAC,sBAAA,GAAxBD,qBAAA,CAA0BR,IAAI,CAACwB,CAAC,IAAIA,CAAC,CAACC,SAAS,KAAK,MAAM,CAAC,cAAAhB,sBAAA,uBAA3DA,sBAAA,CAA6DL,SAAS;IACvFsB,gBAAgB,GAAAhB,cAAA,GAAEzB,OAAO,CAACO,IAAI,cAAAkB,cAAA,uBAAZA,cAAA,CAAciB,eAAe;IAC/CC,WAAW,GAAAjB,gBAAA,GAAE1B,OAAO,CAACG,MAAM,cAAAuB,gBAAA,uBAAdA,gBAAA,CAAgBtB,IAAI;IACjCwC,eAAe,EAAE5C,OAAO;IACxB6C,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACpCC,YAAY,EAAE;EAChB,CAAC,CAAC;EAEJ,IAAIpB,WAAW,EAAE;IACfqB,OAAO,CAACtB,KAAK,CAAC,6BAA6B,EAAEC,WAAW,CAAC;IACzD,OAAO,IAAI;EACb;;EAEA;EACA,MAAM;IACJsB,SAAS;IACTC,cAAc;IACdC,KAAK;IACLC,QAAQ;IACRC,KAAK;IACLC;EACF,CAAC,GAAGC,mBAAmB,CAACxD,OAAO,CAAC;;EAEhC;EACA,MAAM;IAAEyD,IAAI,EAAEC,gBAAgB;IAAE/B;EAAM,CAAC,GAAG,MAAM7B,QAAQ,CACrD+B,IAAI,CAAC,QAAQ,CAAC,CACd8B,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,WAAW,EAAEV,SAAS,CAAC,CAC1BU,EAAE,CAAC,gBAAgB,EAAET,cAAc,CAAC,CACpCS,EAAE,CAAC,OAAO,EAAEN,KAAK;EAClB;EAAA,CACCO,GAAG,CAAC,OAAO,EAAET,KAAK,GAAG,MAAM,CAAC,CAC5BU,GAAG,CAAC,OAAO,EAAEV,KAAK,GAAG,MAAM,CAAC;EAE/B,IAAIzB,KAAK,EAAE;IACTsB,OAAO,CAACtB,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAC9C,OAAO,IAAI;EACb;;EAEA;EACA,MAAMoC,SAAS,GAAGC,aAAa,CAACN,gBAAgB,EAAE1D,OAAO,CAAC;EAE1D,IAAI+D,SAAS,EAAE;IAAA,IAAAE,cAAA;IACb;IACA,MAAMC,uBAAuB,CAACH,SAAS,CAACI,EAAE,EAAEnE,OAAO,CAAC;;IAEpD;IACA,MAAMF,QAAQ,CACX+B,IAAI,CAAC,eAAe,CAAC,CACrBuC,MAAM,CAAC;MACNC,gBAAgB,EAAEN,SAAS,CAACI,EAAE;MAC9BnB,YAAY,EAAE;IAChB,CAAC,CAAC,CACDY,EAAE,CAAC,cAAc,GAAAK,cAAA,GAAEjE,OAAO,CAACO,IAAI,cAAA0D,cAAA,uBAAZA,cAAA,CAAczD,IAAI,CAAC;IAEzC,OAAOuD,SAAS;EAClB;EAEA,OAAO,IAAI;AACb,CAAC;AAED,MAAMP,mBAAmB,GAAIxD,OAAO,IAAK;EAAA,IAAAsE,oBAAA,EAAAC,qBAAA;EACvC,MAAM7D,WAAW,GAAGV,OAAO,CAACU,WAAW,IAAI,CAAC,CAAC;EAC7C,OAAO;IACLwC,SAAS,EAAExC,WAAW,CAACwC,SAAS;IAChCC,cAAc,EAAEzC,WAAW,CAACyC,cAAc;IAC1CC,KAAK,EAAE1C,WAAW,CAAC0C,KAAK;IACxBC,QAAQ,EAAE3C,WAAW,CAAC2C,QAAQ,IAAK3C,WAAW,CAAC8D,MAAM,GAAG9D,WAAW,CAAC0C,KAAM;IAAE;IAC5EE,KAAK,EAAE5C,WAAW,CAAC+D,QAAQ;IAC3BlB,YAAY,GAAAe,oBAAA,GAAE5D,WAAW,CAACI,OAAO,cAAAwD,oBAAA,wBAAAC,qBAAA,GAAnBD,oBAAA,CAAqBvD,IAAI,CAACC,CAAC,IACvCA,CAAC,CAACC,IAAI,MAAMjB,OAAO,CAACgC,MAAM,CAACE,MAAM,KAAK,UAAU,GAAG,MAAM,GAAG,MAAM,CACpE,CAAC,cAAAqC,qBAAA,uBAFaA,qBAAA,CAEXJ;EACL,CAAC;AACH,CAAC;AAED,MAAMH,aAAa,GAAGA,CAACN,gBAAgB,EAAEgB,WAAW,KAAK;EACvD,IAAI,CAAChB,gBAAgB,IAAIA,gBAAgB,CAACiB,MAAM,KAAK,CAAC,EAAE,OAAO,IAAI;;EAEnE;EACA,IAAIjB,gBAAgB,CAACiB,MAAM,KAAK,CAAC,EAAE,OAAOjB,gBAAgB,CAAC,CAAC,CAAC;;EAE7D;EACA,MAAMkB,aAAa,GAAGlB,gBAAgB,CAACmB,GAAG,CAACC,KAAK,IAAI;IAClD,IAAIC,KAAK,GAAG,CAAC;IACb,MAAMC,cAAc,GAAGxB,mBAAmB,CAACkB,WAAW,CAAC;;IAEvD;IACA,IAAII,KAAK,CAACzB,QAAQ,KAAK2B,cAAc,CAAC3B,QAAQ,EAAE0B,KAAK,IAAI,CAAC;;IAE1D;IACA,IAAIE,IAAI,CAACC,GAAG,CAACJ,KAAK,CAAC1B,KAAK,GAAG4B,cAAc,CAAC5B,KAAK,CAAC,GAAG,MAAM,EAAE2B,KAAK,IAAI,CAAC;;IAErE;IACA,IAAID,KAAK,CAACvB,YAAY,KAAKyB,cAAc,CAACzB,YAAY,EAAEwB,KAAK,IAAI,CAAC;;IAElE;IACA,IAAID,KAAK,CAACxB,KAAK,KAAK0B,cAAc,CAAC1B,KAAK,EAAEyB,KAAK,IAAI,CAAC;;IAEpD;IACA,IAAID,KAAK,CAACK,SAAS,CAACpC,WAAW,CAAC,CAAC,CAACd,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK+C,cAAc,CAAC9B,SAAS,EAAE6B,KAAK,IAAI,CAAC;IACxF,IAAID,KAAK,CAACM,cAAc,CAACrC,WAAW,CAAC,CAAC,CAACd,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK+C,cAAc,CAAC7B,cAAc,EAAE4B,KAAK,IAAI,CAAC;IAElG,OAAO;MAAED,KAAK;MAAEC;IAAM,CAAC;EACzB,CAAC,CAAC;;EAEF;EACAH,aAAa,CAACS,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACR,KAAK,GAAGO,CAAC,CAACP,KAAK,CAAC;;EAE/C;EACA,OAAOH,aAAa,CAAC,CAAC,CAAC,CAACG,KAAK,IAAI,EAAE,GAAGH,aAAa,CAAC,CAAC,CAAC,CAACE,KAAK,GAAG,IAAI;AACrE,CAAC;AAED,MAAMZ,uBAAuB,GAAG,MAAAA,CAAOsB,OAAO,EAAEd,WAAW,KAAK;EAC9D,MAAM;IAAE/C;EAAM,CAAC,GAAG,MAAM7B,QAAQ,CAC7B+B,IAAI,CAAC,QAAQ,CAAC,CACduC,MAAM,CAAC;IACNqB,WAAW,EAAE1F,aAAa,CAAC2E,WAAW,CAAC;IACvCgB,cAAc,EAAErF,gBAAgB,CAACqE,WAAW,CAAC;IAC7CiB,sBAAsB,EAAElF,kBAAkB,CAACiE,WAAW,CAAC;IACvDkB,iBAAiB,EAAEC,mBAAmB,CAACnB,WAAW,CAAC;IACnDoB,eAAe,EAAEhG,QAAQ,CAACiG,GAAG,CAAC,kCAAkC,EAAE,CAACrB,WAAW,CAAC;EACjF,CAAC,CAAC,CACDd,EAAE,CAAC,IAAI,EAAE4B,OAAO,CAAC;EAEpB,IAAI7D,KAAK,EAAE;IACTsB,OAAO,CAACtB,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;EAC9D;AACF,CAAC;AAED,MAAMkE,mBAAmB,GAAI7F,OAAO,IAAK;EACvC,IAAIA,OAAO,CAACC,WAAW,KAAK,KAAK,EAAE;IAAA,IAAA+F,gBAAA,EAAAC,qBAAA,EAAAC,gBAAA,EAAAC,qBAAA,EAAAC,gBAAA,EAAAC,qBAAA;IACjC,KAAAL,gBAAA,GAAIhG,OAAO,CAACG,MAAM,cAAA6F,gBAAA,gBAAAC,qBAAA,GAAdD,gBAAA,CAAgB5F,IAAI,cAAA6F,qBAAA,eAApBA,qBAAA,CAAsBK,QAAQ,CAAC,MAAM,CAAC,EAAE,OAAO,SAAS;IAC5D,KAAAJ,gBAAA,GAAIlG,OAAO,CAACG,MAAM,cAAA+F,gBAAA,gBAAAC,qBAAA,GAAdD,gBAAA,CAAgB9F,IAAI,cAAA+F,qBAAA,eAApBA,qBAAA,CAAsBG,QAAQ,CAAC,MAAM,CAAC,EAAE,OAAO,UAAU;IAC7D,KAAAF,gBAAA,GAAIpG,OAAO,CAACG,MAAM,cAAAiG,gBAAA,gBAAAC,qBAAA,GAAdD,gBAAA,CAAgBhG,IAAI,cAAAiG,qBAAA,eAApBA,qBAAA,CAAsBC,QAAQ,CAAC,MAAM,CAAC,EAAE,OAAO,UAAU;EAC/D;EACA,OAAO,SAAS;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}