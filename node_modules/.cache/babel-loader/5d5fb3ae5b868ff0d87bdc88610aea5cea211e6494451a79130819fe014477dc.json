{"ast":null,"code":"import { supabase } from '../supabaseClient';\nconst getFICCStatus = message => {\n  if (message.messageType === '509') {\n    var _message$status;\n    return ((_message$status = message.status) === null || _message$status === void 0 ? void 0 : _message$status.type) || 'PENDING';\n  }\n  return 'PENDING';\n};\nconst getFICCReference = message => {\n  var _message$genl;\n  return ((_message$genl = message.genl) === null || _message$genl === void 0 ? void 0 : _message$genl.seme) || null;\n};\nconst getCounterpartyRef = message => {\n  if (message.confDetails) {\n    var _message$confDetails$, _message$confDetails$2;\n    // For MT515/MT518 messages\n    const buyerParty = (_message$confDetails$ = message.confDetails.parties) === null || _message$confDetails$ === void 0 ? void 0 : _message$confDetails$.find(p => p.role === 'BUYR');\n    const sellerParty = (_message$confDetails$2 = message.confDetails.parties) === null || _message$confDetails$2 === void 0 ? void 0 : _message$confDetails$2.find(p => p.role === 'SELL');\n    return (buyerParty === null || buyerParty === void 0 ? void 0 : buyerParty.reference) || (sellerParty === null || sellerParty === void 0 ? void 0 : sellerParty.reference);\n  }\n  return null;\n};\nexport const matchTradeToFICCMessage = async message => {\n  var _message$genl2, _message$genl3, _message$genl3$refere, _message$genl3$refere2, _message$genl4, _message$status2;\n  // First store the message\n  const {\n    error: insertError\n  } = await supabase.from('ficc_messages').insert({\n    message_type: message.header.messageType.split('/')[0],\n    sender: message.header.sender,\n    receiver: message.header.receiver,\n    reference_id: (_message$genl2 = message.genl) === null || _message$genl2 === void 0 ? void 0 : _message$genl2.seme,\n    trade_reference: (_message$genl3 = message.genl) === null || _message$genl3 === void 0 ? void 0 : (_message$genl3$refere = _message$genl3.references) === null || _message$genl3$refere === void 0 ? void 0 : (_message$genl3$refere2 = _message$genl3$refere.find(r => r.qualifier === 'MAST')) === null || _message$genl3$refere2 === void 0 ? void 0 : _message$genl3$refere2.reference,\n    message_function: (_message$genl4 = message.genl) === null || _message$genl4 === void 0 ? void 0 : _message$genl4.messageFunction,\n    status_type: (_message$status2 = message.status) === null || _message$status2 === void 0 ? void 0 : _message$status2.type,\n    message_content: message\n  });\n  if (insertError) {\n    console.error('Error storing FICC message:', insertError);\n    return null;\n  }\n\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    quantity,\n    cusip,\n    counterparty\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const {\n    data: potentialMatches,\n    error\n  } = await supabase.from('trades').select('*').eq('tradedate', tradeDate).eq('settlementdate', settlementDate).eq('cusip', cusip)\n  // Add tolerance for price/amount matching\n  .gte('price', price * 0.9999).lte('price', price * 1.0001);\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  if (bestMatch) {\n    var _message$genl5;\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n\n    // Update ficc_message with matched trade\n    await supabase.from('ficc_messages').update({\n      matched_trade_id: bestMatch.id,\n      is_processed: true\n    }).eq('reference_id', (_message$genl5 = message.genl) === null || _message$genl5 === void 0 ? void 0 : _message$genl5.seme);\n    return bestMatch;\n  }\n  return null;\n};\nconst extractTradeDetails = message => {\n  var _confDetails$parties, _confDetails$parties$;\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    quantity: confDetails.quantity || confDetails.amount / confDetails.price,\n    // Calculate quantity if not provided\n    cusip: confDetails.security,\n    counterparty: (_confDetails$parties = confDetails.parties) === null || _confDetails$parties === void 0 ? void 0 : (_confDetails$parties$ = _confDetails$parties.find(p => p.role === (message.header.sender === 'GSCCTRRS' ? 'BUYR' : 'SELL'))) === null || _confDetails$parties$ === void 0 ? void 0 : _confDetails$parties$.id\n  };\n};\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  if (!potentialMatches || potentialMatches.length === 0) return null;\n\n  // If only one match, return it\n  if (potentialMatches.length === 1) return potentialMatches[0];\n\n  // Score each potential match\n  const scoredMatches = potentialMatches.map(trade => {\n    let score = 0;\n    const messageDetails = extractTradeDetails(ficcMessage);\n\n    // Exact quantity match\n    if (trade.quantity === messageDetails.quantity) score += 5;\n\n    // Price match within tolerance\n    if (Math.abs(trade.price - messageDetails.price) < 0.0001) score += 3;\n\n    // Counterparty match\n    if (trade.counterparty === messageDetails.counterparty) score += 4;\n\n    // CUSIP match\n    if (trade.cusip === messageDetails.cusip) score += 5;\n\n    // Date matches\n    if (trade.tradedate.toISOString().split('T')[0] === messageDetails.tradeDate) score += 2;\n    if (trade.settlementdate.toISOString().split('T')[0] === messageDetails.settlementDate) score += 2;\n    return {\n      trade,\n      score\n    };\n  });\n\n  // Sort by score descending\n  scoredMatches.sort((a, b) => b.score - a.score);\n\n  // Return the trade with highest score if it meets minimum threshold\n  return scoredMatches[0].score >= 10 ? scoredMatches[0].trade : null;\n};\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const {\n    error\n  } = await supabase.from('trades').update({\n    ficc_status: getFICCStatus(ficcMessage),\n    ficc_reference: getFICCReference(ficcMessage),\n    counterparty_reference: getCounterpartyRef(ficcMessage),\n    comparison_status: getComparisonStatus(ficcMessage),\n    message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n  }).eq('id', tradeId);\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n};\nconst getComparisonStatus = message => {\n  if (message.messageType === '509') {\n    var _message$status3, _message$status3$type, _message$status4, _message$status4$type, _message$status5, _message$status5$type;\n    if ((_message$status3 = message.status) !== null && _message$status3 !== void 0 && (_message$status3$type = _message$status3.type) !== null && _message$status3$type !== void 0 && _message$status3$type.includes('MACH')) return 'Matched';\n    if ((_message$status4 = message.status) !== null && _message$status4 !== void 0 && (_message$status4$type = _message$status4.type) !== null && _message$status4$type !== void 0 && _message$status4$type.includes('REJT')) return 'Rejected';\n    if ((_message$status5 = message.status) !== null && _message$status5 !== void 0 && (_message$status5$type = _message$status5.type) !== null && _message$status5$type !== void 0 && _message$status5$type.includes('PACK')) return 'Accepted';\n  }\n  return 'Pending';\n};","map":{"version":3,"names":["supabase","getFICCStatus","message","messageType","_message$status","status","type","getFICCReference","_message$genl","genl","seme","getCounterpartyRef","confDetails","_message$confDetails$","_message$confDetails$2","buyerParty","parties","find","p","role","sellerParty","reference","matchTradeToFICCMessage","_message$genl2","_message$genl3","_message$genl3$refere","_message$genl3$refere2","_message$genl4","_message$status2","error","insertError","from","insert","message_type","header","split","sender","receiver","reference_id","trade_reference","references","r","qualifier","message_function","messageFunction","status_type","message_content","console","tradeDate","settlementDate","price","quantity","cusip","counterparty","extractTradeDetails","data","potentialMatches","select","eq","gte","lte","bestMatch","findBestMatch","_message$genl5","updateTradeWithFICCInfo","id","update","matched_trade_id","is_processed","_confDetails$parties","_confDetails$parties$","amount","security","ficcMessage","length","scoredMatches","map","trade","score","messageDetails","Math","abs","tradedate","toISOString","settlementdate","sort","a","b","tradeId","ficc_status","ficc_reference","counterparty_reference","comparison_status","getComparisonStatus","message_history","raw","_message$status3","_message$status3$type","_message$status4","_message$status4$type","_message$status5","_message$status5$type","includes"],"sources":["/Users/joelaird/TradeRecon/src/services/matchingService.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\nconst getFICCStatus = (message) => {\n  if (message.messageType === '509') {\n    return message.status?.type || 'PENDING';\n  }\n  return 'PENDING';\n};\n\nconst getFICCReference = (message) => {\n  return message.genl?.seme || null;\n};\n\nconst getCounterpartyRef = (message) => {\n  if (message.confDetails) {\n    // For MT515/MT518 messages\n    const buyerParty = message.confDetails.parties?.find(p => p.role === 'BUYR');\n    const sellerParty = message.confDetails.parties?.find(p => p.role === 'SELL');\n    return buyerParty?.reference || sellerParty?.reference;\n  }\n  return null;\n};\n\nexport const matchTradeToFICCMessage = async (message) => {\n  // First store the message\n  const { error: insertError } = await supabase\n    .from('ficc_messages')\n    .insert({\n      message_type: message.header.messageType.split('/')[0],\n      sender: message.header.sender,\n      receiver: message.header.receiver,\n      reference_id: message.genl?.seme,\n      trade_reference: message.genl?.references?.find(r => r.qualifier === 'MAST')?.reference,\n      message_function: message.genl?.messageFunction,\n      status_type: message.status?.type,\n      message_content: message\n    });\n\n  if (insertError) {\n    console.error('Error storing FICC message:', insertError);\n    return null;\n  }\n\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    quantity,\n    cusip,\n    counterparty\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const { data: potentialMatches, error } = await supabase\n    .from('trades')\n    .select('*')\n    .eq('tradedate', tradeDate)\n    .eq('settlementdate', settlementDate)\n    .eq('cusip', cusip)\n    // Add tolerance for price/amount matching\n    .gte('price', price * 0.9999)\n    .lte('price', price * 1.0001);\n\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  \n  if (bestMatch) {\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n    \n    // Update ficc_message with matched trade\n    await supabase\n      .from('ficc_messages')\n      .update({ \n        matched_trade_id: bestMatch.id,\n        is_processed: true\n      })\n      .eq('reference_id', message.genl?.seme);\n\n    return bestMatch;\n  }\n\n  return null;\n};\n\nconst extractTradeDetails = (message) => {\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    quantity: confDetails.quantity || (confDetails.amount / confDetails.price), // Calculate quantity if not provided\n    cusip: confDetails.security,\n    counterparty: confDetails.parties?.find(p => \n      p.role === (message.header.sender === 'GSCCTRRS' ? 'BUYR' : 'SELL')\n    )?.id\n  };\n};\n\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  if (!potentialMatches || potentialMatches.length === 0) return null;\n\n  // If only one match, return it\n  if (potentialMatches.length === 1) return potentialMatches[0];\n\n  // Score each potential match\n  const scoredMatches = potentialMatches.map(trade => {\n    let score = 0;\n    const messageDetails = extractTradeDetails(ficcMessage);\n\n    // Exact quantity match\n    if (trade.quantity === messageDetails.quantity) score += 5;\n\n    // Price match within tolerance\n    if (Math.abs(trade.price - messageDetails.price) < 0.0001) score += 3;\n\n    // Counterparty match\n    if (trade.counterparty === messageDetails.counterparty) score += 4;\n\n    // CUSIP match\n    if (trade.cusip === messageDetails.cusip) score += 5;\n\n    // Date matches\n    if (trade.tradedate.toISOString().split('T')[0] === messageDetails.tradeDate) score += 2;\n    if (trade.settlementdate.toISOString().split('T')[0] === messageDetails.settlementDate) score += 2;\n\n    return { trade, score };\n  });\n\n  // Sort by score descending\n  scoredMatches.sort((a, b) => b.score - a.score);\n\n  // Return the trade with highest score if it meets minimum threshold\n  return scoredMatches[0].score >= 10 ? scoredMatches[0].trade : null;\n};\n\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const { error } = await supabase\n    .from('trades')\n    .update({\n      ficc_status: getFICCStatus(ficcMessage),\n      ficc_reference: getFICCReference(ficcMessage),\n      counterparty_reference: getCounterpartyRef(ficcMessage),\n      comparison_status: getComparisonStatus(ficcMessage),\n      message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n    })\n    .eq('id', tradeId);\n\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n};\n\nconst getComparisonStatus = (message) => {\n  if (message.messageType === '509') {\n    if (message.status?.type?.includes('MACH')) return 'Matched';\n    if (message.status?.type?.includes('REJT')) return 'Rejected';\n    if (message.status?.type?.includes('PACK')) return 'Accepted';\n  }\n  return 'Pending';\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}