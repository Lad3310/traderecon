{"ast":null,"code":"import { supabase } from '../supabaseClient';\nexport const matchTradeToFICCMessage = async message => {\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    amount,\n    security\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const {\n    data: potentialMatches,\n    error\n  } = await supabase.from('trades').select('*').eq('trade_date', tradeDate).eq('settlement_date', settlementDate).eq('security_id', security)\n  // Add tolerance for price/amount matching\n  .gte('amount', amount * 0.9999).lte('amount', amount * 1.0001);\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  if (bestMatch) {\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n    return bestMatch;\n  }\n  return null;\n};\nconst extractTradeDetails = message => {\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    amount: confDetails.amount,\n    security: confDetails.security\n  };\n};\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  // Implement matching logic here\n  // Consider factors like:\n  // - Exact amount match\n  // - Price match within tolerance\n  // - Counterparty information\n  // - Trade time proximity\n  // Return the best matching trade or null\n};\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const {\n    error\n  } = await supabase.from('trades').update({\n    ficc_status: getFICCStatus(ficcMessage),\n    ficc_reference: getFICCReference(ficcMessage),\n    counterparty_reference: getCounterpartyRef(ficcMessage),\n    message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n  }).eq('id', tradeId);\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n};","map":{"version":3,"names":["supabase","matchTradeToFICCMessage","message","tradeDate","settlementDate","price","amount","security","extractTradeDetails","data","potentialMatches","error","from","select","eq","gte","lte","console","bestMatch","findBestMatch","updateTradeWithFICCInfo","id","confDetails","ficcMessage","tradeId","update","ficc_status","getFICCStatus","ficc_reference","getFICCReference","counterparty_reference","getCounterpartyRef","message_history","raw"],"sources":["/Users/joelaird/TradeRecon/src/services/matchingService.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\nexport const matchTradeToFICCMessage = async (message) => {\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    amount,\n    security\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const { data: potentialMatches, error } = await supabase\n    .from('trades')\n    .select('*')\n    .eq('trade_date', tradeDate)\n    .eq('settlement_date', settlementDate)\n    .eq('security_id', security)\n    // Add tolerance for price/amount matching\n    .gte('amount', amount * 0.9999)\n    .lte('amount', amount * 1.0001);\n\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  \n  if (bestMatch) {\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n    return bestMatch;\n  }\n\n  return null;\n};\n\nconst extractTradeDetails = (message) => {\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    amount: confDetails.amount,\n    security: confDetails.security\n  };\n};\n\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  // Implement matching logic here\n  // Consider factors like:\n  // - Exact amount match\n  // - Price match within tolerance\n  // - Counterparty information\n  // - Trade time proximity\n  // Return the best matching trade or null\n};\n\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const { error } = await supabase\n    .from('trades')\n    .update({\n      ficc_status: getFICCStatus(ficcMessage),\n      ficc_reference: getFICCReference(ficcMessage),\n      counterparty_reference: getCounterpartyRef(ficcMessage),\n      message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n    })\n    .eq('id', tradeId);\n\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n}; "],"mappings":"AAAA,SAASA,QAAQ,QAAQ,mBAAmB;AAE5C,OAAO,MAAMC,uBAAuB,GAAG,MAAOC,OAAO,IAAK;EACxD;EACA,MAAM;IACJC,SAAS;IACTC,cAAc;IACdC,KAAK;IACLC,MAAM;IACNC;EACF,CAAC,GAAGC,mBAAmB,CAACN,OAAO,CAAC;;EAEhC;EACA,MAAM;IAAEO,IAAI,EAAEC,gBAAgB;IAAEC;EAAM,CAAC,GAAG,MAAMX,QAAQ,CACrDY,IAAI,CAAC,QAAQ,CAAC,CACdC,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,YAAY,EAAEX,SAAS,CAAC,CAC3BW,EAAE,CAAC,iBAAiB,EAAEV,cAAc,CAAC,CACrCU,EAAE,CAAC,aAAa,EAAEP,QAAQ;EAC3B;EAAA,CACCQ,GAAG,CAAC,QAAQ,EAAET,MAAM,GAAG,MAAM,CAAC,CAC9BU,GAAG,CAAC,QAAQ,EAAEV,MAAM,GAAG,MAAM,CAAC;EAEjC,IAAIK,KAAK,EAAE;IACTM,OAAO,CAACN,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAC9C,OAAO,IAAI;EACb;;EAEA;EACA,MAAMO,SAAS,GAAGC,aAAa,CAACT,gBAAgB,EAAER,OAAO,CAAC;EAE1D,IAAIgB,SAAS,EAAE;IACb;IACA,MAAME,uBAAuB,CAACF,SAAS,CAACG,EAAE,EAAEnB,OAAO,CAAC;IACpD,OAAOgB,SAAS;EAClB;EAEA,OAAO,IAAI;AACb,CAAC;AAED,MAAMV,mBAAmB,GAAIN,OAAO,IAAK;EACvC,MAAMoB,WAAW,GAAGpB,OAAO,CAACoB,WAAW,IAAI,CAAC,CAAC;EAC7C,OAAO;IACLnB,SAAS,EAAEmB,WAAW,CAACnB,SAAS;IAChCC,cAAc,EAAEkB,WAAW,CAAClB,cAAc;IAC1CC,KAAK,EAAEiB,WAAW,CAACjB,KAAK;IACxBC,MAAM,EAAEgB,WAAW,CAAChB,MAAM;IAC1BC,QAAQ,EAAEe,WAAW,CAACf;EACxB,CAAC;AACH,CAAC;AAED,MAAMY,aAAa,GAAGA,CAACT,gBAAgB,EAAEa,WAAW,KAAK;EACvD;EACA;EACA;EACA;EACA;EACA;EACA;AAAA,CACD;AAED,MAAMH,uBAAuB,GAAG,MAAAA,CAAOI,OAAO,EAAED,WAAW,KAAK;EAC9D,MAAM;IAAEZ;EAAM,CAAC,GAAG,MAAMX,QAAQ,CAC7BY,IAAI,CAAC,QAAQ,CAAC,CACda,MAAM,CAAC;IACNC,WAAW,EAAEC,aAAa,CAACJ,WAAW,CAAC;IACvCK,cAAc,EAAEC,gBAAgB,CAACN,WAAW,CAAC;IAC7CO,sBAAsB,EAAEC,kBAAkB,CAACR,WAAW,CAAC;IACvDS,eAAe,EAAEhC,QAAQ,CAACiC,GAAG,CAAC,kCAAkC,EAAE,CAACV,WAAW,CAAC;EACjF,CAAC,CAAC,CACDT,EAAE,CAAC,IAAI,EAAEU,OAAO,CAAC;EAEpB,IAAIb,KAAK,EAAE;IACTM,OAAO,CAACN,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;EAC9D;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}