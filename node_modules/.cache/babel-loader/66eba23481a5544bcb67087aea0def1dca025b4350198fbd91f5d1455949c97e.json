{"ast":null,"code":"import { supabase } from '../supabaseClient';\nconst getFICCStatus = message => {\n  if (message.messageType === '509') {\n    var _message$status;\n    return ((_message$status = message.status) === null || _message$status === void 0 ? void 0 : _message$status.type) || 'PENDING';\n  }\n  return 'PENDING';\n};\nconst getFICCReference = message => {\n  var _message$genl;\n  return ((_message$genl = message.genl) === null || _message$genl === void 0 ? void 0 : _message$genl.seme) || null;\n};\nconst getCounterpartyRef = message => {\n  if (message.confDetails) {\n    var _message$confDetails$, _message$confDetails$2;\n    // For MT515/MT518 messages\n    const buyerParty = (_message$confDetails$ = message.confDetails.parties) === null || _message$confDetails$ === void 0 ? void 0 : _message$confDetails$.find(p => p.role === 'BUYR');\n    const sellerParty = (_message$confDetails$2 = message.confDetails.parties) === null || _message$confDetails$2 === void 0 ? void 0 : _message$confDetails$2.find(p => p.role === 'SELL');\n    return (buyerParty === null || buyerParty === void 0 ? void 0 : buyerParty.reference) || (sellerParty === null || sellerParty === void 0 ? void 0 : sellerParty.reference);\n  }\n  return null;\n};\nexport const matchTradeToFICCMessage = async message => {\n  var _message$genl2, _message$genl3, _message$genl3$refere, _message$genl3$refere2, _message$genl4, _message$status2;\n  // First store the message\n  const {\n    error: insertError\n  } = await supabase.from('ficc_messages').insert({\n    message_type: message.header.messageType.split('/')[0],\n    sender: message.header.sender,\n    receiver: message.header.receiver,\n    reference_id: (_message$genl2 = message.genl) === null || _message$genl2 === void 0 ? void 0 : _message$genl2.seme,\n    trade_reference: (_message$genl3 = message.genl) === null || _message$genl3 === void 0 ? void 0 : (_message$genl3$refere = _message$genl3.references) === null || _message$genl3$refere === void 0 ? void 0 : (_message$genl3$refere2 = _message$genl3$refere.find(r => r.qualifier === 'MAST')) === null || _message$genl3$refere2 === void 0 ? void 0 : _message$genl3$refere2.reference,\n    message_function: (_message$genl4 = message.genl) === null || _message$genl4 === void 0 ? void 0 : _message$genl4.messageFunction,\n    status_type: (_message$status2 = message.status) === null || _message$status2 === void 0 ? void 0 : _message$status2.type,\n    message_content: message\n  });\n  if (insertError) {\n    console.error('Error storing FICC message:', insertError);\n    return null;\n  }\n\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    amount,\n    security\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const {\n    data: potentialMatches,\n    error\n  } = await supabase.from('trades').select('*').eq('tradedate', tradeDate).eq('settlementdate', settlementDate).eq('cusip', security)\n  // Add tolerance for price/amount matching\n  .gte('price', price * 0.9999).lte('price', price * 1.0001);\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  if (bestMatch) {\n    var _message$genl5;\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n\n    // Update ficc_message with matched trade\n    await supabase.from('ficc_messages').update({\n      matched_trade_id: bestMatch.id,\n      is_processed: true\n    }).eq('reference_id', (_message$genl5 = message.genl) === null || _message$genl5 === void 0 ? void 0 : _message$genl5.seme);\n    return bestMatch;\n  }\n  return null;\n};\nconst extractTradeDetails = message => {\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    amount: confDetails.amount,\n    security: confDetails.security\n  };\n};\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  if (!potentialMatches || potentialMatches.length === 0) return null;\n\n  // If only one match, return it\n  if (potentialMatches.length === 1) return potentialMatches[0];\n\n  // Score each potential match\n  const scoredMatches = potentialMatches.map(trade => {\n    let score = 0;\n    const messageDetails = extractTradeDetails(ficcMessage);\n\n    // Exact amount match\n    if (trade.price * trade.quantity === messageDetails.amount) score += 5;\n\n    // Price match\n    if (Math.abs(trade.price - messageDetails.price) < 0.0001) score += 3;\n\n    // Counterparty match\n    if (trade.counterparty === messageDetails.counterparty) score += 4;\n\n    // Time proximity (if trade times available)\n    if (trade.tradedate === messageDetails.tradeDate) score += 2;\n    return {\n      trade,\n      score\n    };\n  });\n\n  // Sort by score descending\n  scoredMatches.sort((a, b) => b.score - a.score);\n\n  // Return the trade with highest score if it meets minimum threshold\n  return scoredMatches[0].score >= 5 ? scoredMatches[0].trade : null;\n};\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const {\n    error\n  } = await supabase.from('trades').update({\n    ficc_status: getFICCStatus(ficcMessage),\n    ficc_reference: getFICCReference(ficcMessage),\n    counterparty_reference: getCounterpartyRef(ficcMessage),\n    message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n  }).eq('id', tradeId);\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n};","map":{"version":3,"names":["supabase","getFICCStatus","message","messageType","_message$status","status","type","getFICCReference","_message$genl","genl","seme","getCounterpartyRef","confDetails","_message$confDetails$","_message$confDetails$2","buyerParty","parties","find","p","role","sellerParty","reference","matchTradeToFICCMessage","_message$genl2","_message$genl3","_message$genl3$refere","_message$genl3$refere2","_message$genl4","_message$status2","error","insertError","from","insert","message_type","header","split","sender","receiver","reference_id","trade_reference","references","r","qualifier","message_function","messageFunction","status_type","message_content","console","tradeDate","settlementDate","price","amount","security","extractTradeDetails","data","potentialMatches","select","eq","gte","lte","bestMatch","findBestMatch","_message$genl5","updateTradeWithFICCInfo","id","update","matched_trade_id","is_processed","ficcMessage","length","scoredMatches","map","trade","score","messageDetails","quantity","Math","abs","counterparty","tradedate","sort","a","b","tradeId","ficc_status","ficc_reference","counterparty_reference","message_history","raw"],"sources":["/Users/joelaird/TradeRecon/src/services/matchingService.js"],"sourcesContent":["import { supabase } from '../supabaseClient';\n\nconst getFICCStatus = (message) => {\n  if (message.messageType === '509') {\n    return message.status?.type || 'PENDING';\n  }\n  return 'PENDING';\n};\n\nconst getFICCReference = (message) => {\n  return message.genl?.seme || null;\n};\n\nconst getCounterpartyRef = (message) => {\n  if (message.confDetails) {\n    // For MT515/MT518 messages\n    const buyerParty = message.confDetails.parties?.find(p => p.role === 'BUYR');\n    const sellerParty = message.confDetails.parties?.find(p => p.role === 'SELL');\n    return buyerParty?.reference || sellerParty?.reference;\n  }\n  return null;\n};\n\nexport const matchTradeToFICCMessage = async (message) => {\n  // First store the message\n  const { error: insertError } = await supabase\n    .from('ficc_messages')\n    .insert({\n      message_type: message.header.messageType.split('/')[0],\n      sender: message.header.sender,\n      receiver: message.header.receiver,\n      reference_id: message.genl?.seme,\n      trade_reference: message.genl?.references?.find(r => r.qualifier === 'MAST')?.reference,\n      message_function: message.genl?.messageFunction,\n      status_type: message.status?.type,\n      message_content: message\n    });\n\n  if (insertError) {\n    console.error('Error storing FICC message:', insertError);\n    return null;\n  }\n\n  // Extract key matching fields from FICC message\n  const {\n    tradeDate,\n    settlementDate,\n    price,\n    amount,\n    security\n  } = extractTradeDetails(message);\n\n  // Query our trades table for potential matches\n  const { data: potentialMatches, error } = await supabase\n    .from('trades')\n    .select('*')\n    .eq('tradedate', tradeDate)\n    .eq('settlementdate', settlementDate)\n    .eq('cusip', security)\n    // Add tolerance for price/amount matching\n    .gte('price', price * 0.9999)\n    .lte('price', price * 1.0001);\n\n  if (error) {\n    console.error('Error finding matches:', error);\n    return null;\n  }\n\n  // Find best match using additional criteria\n  const bestMatch = findBestMatch(potentialMatches, message);\n  \n  if (bestMatch) {\n    // Update trade with FICC information\n    await updateTradeWithFICCInfo(bestMatch.id, message);\n    \n    // Update ficc_message with matched trade\n    await supabase\n      .from('ficc_messages')\n      .update({ \n        matched_trade_id: bestMatch.id,\n        is_processed: true\n      })\n      .eq('reference_id', message.genl?.seme);\n\n    return bestMatch;\n  }\n\n  return null;\n};\n\nconst extractTradeDetails = (message) => {\n  const confDetails = message.confDetails || {};\n  return {\n    tradeDate: confDetails.tradeDate,\n    settlementDate: confDetails.settlementDate,\n    price: confDetails.price,\n    amount: confDetails.amount,\n    security: confDetails.security\n  };\n};\n\nconst findBestMatch = (potentialMatches, ficcMessage) => {\n  if (!potentialMatches || potentialMatches.length === 0) return null;\n\n  // If only one match, return it\n  if (potentialMatches.length === 1) return potentialMatches[0];\n\n  // Score each potential match\n  const scoredMatches = potentialMatches.map(trade => {\n    let score = 0;\n    const messageDetails = extractTradeDetails(ficcMessage);\n\n    // Exact amount match\n    if (trade.price * trade.quantity === messageDetails.amount) score += 5;\n\n    // Price match\n    if (Math.abs(trade.price - messageDetails.price) < 0.0001) score += 3;\n\n    // Counterparty match\n    if (trade.counterparty === messageDetails.counterparty) score += 4;\n\n    // Time proximity (if trade times available)\n    if (trade.tradedate === messageDetails.tradeDate) score += 2;\n\n    return { trade, score };\n  });\n\n  // Sort by score descending\n  scoredMatches.sort((a, b) => b.score - a.score);\n\n  // Return the trade with highest score if it meets minimum threshold\n  return scoredMatches[0].score >= 5 ? scoredMatches[0].trade : null;\n};\n\nconst updateTradeWithFICCInfo = async (tradeId, ficcMessage) => {\n  const { error } = await supabase\n    .from('trades')\n    .update({\n      ficc_status: getFICCStatus(ficcMessage),\n      ficc_reference: getFICCReference(ficcMessage),\n      counterparty_reference: getCounterpartyRef(ficcMessage),\n      message_history: supabase.raw('array_append(message_history, ?)', [ficcMessage])\n    })\n    .eq('id', tradeId);\n\n  if (error) {\n    console.error('Error updating trade with FICC info:', error);\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}